# Write your own R package {#package-from-scratch}

```{r include = FALSE}
source("common.R")
```

<!--Original content: http://stat545.com/packages06_foofactors-package.html-->

This section closely tracks with content from the book [R Packages][r-pkgs2] by Hadley Wickham and Jenny Bryan [-@wickham-unpub], specifically the [The Whole Game][r-pkgs2-whole-game] chapter. The material in this chapter is, however, accurate and up-to-date, although a bit longer than [The Whole Game][r-pkgs2-whole-game]. The [R Packages][r-pkgs2] book is a great place to go next to learn more. 


```{r, include = FALSE}
knitr::opts_chunk$set(cache = FALSE, error = TRUE, warning = FALSE)

## do you want to see how this sausage is made?
debug <- FALSE
github <- FALSE

## do we build the toy package? if so, where?
## * NA            --> no, don't build it
## * "tmp_user"    --> build in ~/tmp/foofactors, so it's easy to access after
## * "tmp_session" --> build in session temp dir, it's disposable
where <- "tmp_session"
```

## Why `devtools`?

We use the [`devtools`][devtools-web] package to facilitate package development. It’s on [CRAN][devtools-cran] and developed on [GitHub][devtools-github]. Why `devtools`? 

* Ensure your package source has the format of a valid R package
* Provide a fluid workflow for package development: tweak it, use it, ... lather, rinse, repeat
  
The source of an R package is a highly structured set of files that reside in a dedicated directory on your computer. It can be beneficial to also make this directory an RStudio project and a Git repository and, eventually, associate it with a GitHub remote. `devtools` ensures that your initial set up is correct and helps you keep it that way as your package evolves.

As you develop the functions in your package, you need to take them out regularly for a test drive. How do you plan to get them into memory? Various workflows come to mind:

  * Copy/paste or use IDE magic to send the function definition to R console.
  * Use `source()` or IDE magic to evaluate the `.R` file with function definition.
  * Use `R CMD INSTALL` in the shell then, in R, load your package.

These workflows may be tolerable at first, but they grow old very quickly. The first two are also suboptimal with respect to package namespace issues. An awkward workflow can lead to bad habits, such as not test driving your package very often, and can make the process totally unpleasant.

`devtools` helps you iterate quickly between developing your functions and checking if they work as intended.


## System prep

We assume you have [configured your system for R package development](#system-prep). This will ensure you have all the right software installed and that it's updated. Ignoring this prep will only lead to heartache. **Do it.**

## Load `devtools` and friends

Load the `devtools` package, which is the public face of a set of packages that support various aspects of package development.

```{r}
library(devtools)
```

Since `devtools` is a workflow package, you may consider loading it automatically in all of your interactive R sessions. In general, it's not a great idea to load packages this way, as it invites you to create R scripts that don't reflect all of their dependencies via explicit calls to `library(foo)`. But `devtools` is meant to smooth the process of package development and is, therefore, unlikely to get baked into any analysis scripts. The pros may outweigh the cons in this case.

You can do this by adding these lines to your `.Rprofile`:

```{r eval = FALSE}
if (interactive()) {
  suppressMessages(require(devtools))
}
```

The helper `use_devtools()` creates this file, if needed, opens it for editing, and puts the necessary lines of code on the clipboard and the screen. Another package you may want to handle this way is [`testthat`][testthat-web].

For presentation purposes only, we use the [`tidyverse`][tidyverse-web], for light data wrangling, and [`fs`][fs-web], for filesystem work.

```{r, R.options = list(tidyverse.quiet = TRUE)}
library(tidyverse)
library(fs)
```

You may notice that some functions we'll use in this chapter start with `use_*()`. These functions derive from the [`usethis` package][usethis-web], which is also on [CRAN][usethis-cran] and developed on [GitHub][usethis-github]. Generally, you should not need to worry about these different packages because `devtools` installs them all automatically for you. `devtools` remains the primary package developers will interact with when writing R packages; it just relies on these other packages internally for most of the functionality. 

Nevertheless, as you work through the development of this toy package, it may be useful to notice that the `use_*()` functions can often be "chatty", explaining what the function is doing and assigning you tasks to complete. For example:

+ `✔` indicates something `usethis` has done for you,
+ `●` indicates that you'll need to do some work yourself. 

You can think of the `usethis::use_*()` family as functions that simplify things that you do once (like creating a file), whereas `devtools` automates things that you do multiple times (like running all tests).

## Toy package: `foofactors`

We use various functions from `devtools` to build a small toy package from scratch, with features commonly seen in released packages:

* Functions to address a specific need, such as helpers to work with factors.
* Access to established workflows for installation, getting help, and checking basic quality.
* Version control and an open development process.
  - This is completely optional in your work, but recommended. You'll see how Git and GitHub helps us expose all the intermediate stages of our package.
* Documentation for individual functions via [`roxygen2`][roxygen2-cran].
* Unit testing with [`testthat`][testthat-web].
* Documentation for the package as a whole via an executable `README.Rmd`.

We call the package `foofactors` and it will have a couple functions for handling factors. Please note that these functions are super simple and definitely not the point! For a proper package for factor handling, please see the [`forcats`][forcats-web] package.

The `foofactors` package itself is not our goal here. It is a device for demonstrating a typical workflow for package development with `devtools.`


## Peek at the finished product

The `foofactors` package is tracked during its development with the Git version control system. This is purely optional and you can certainly follow along without implementing this. A nice side benefit is that we eventually connect it to a remote repository on GitHub, which means you can see the glorious result we are working towards by visiting `foofactors` on GitHub: <https://github.com/jennybc/foofactors>. By inspecting the [commit history](https://github.com/jennybc/foofactors/commits/master) and especially the diffs, you can see exactly what changes at each step of the process laid out below.

## `create_package()`

The `create_package()` function initializes a new package in a new directory on your computer. The new package will comply with all `devtools` conventions and will immediately pass `R CMD check`. Ideally, your package will always be in this happy state and it is something you should verify often.

Make a deliberate choice about where to create this package on your computer. It should probably be in your home directory, alongside your other R projects. It should not be in, for example, an R package library, which holds packages that have already been built and installed. The conversion of the source package we are creating here into an installed package is part of what `devtools` facilitates. Don't try to do `devtools`' job for it.

Substitute your chosen path into a `create_package()` call like this:

```{r create-package-fake, eval = FALSE}
create_package("~/path/to/foofactors")
```

We have to work in a temp directory, because this book is built non-interactively, in the cloud. Behind the scenes, we're executing our own `create_package()` command, but don't be surprised if our output differs a bit from yours.

```{r configure, include = FALSE}
# from Whole Game
where <- match.arg(where, choices = c(NA, "tmp_user", "tmp_session"))
create <- !is.na(where)
where <- switch(
  where,
  tmp_user = fs::path_home("tmp"),
  tmp_session = fs::path_temp(),
  NULL
)
foopath <- path(where, "foofactors")
if (!is.null(where)) {
  if (fs::dir_exists(foopath)) {
    fs::dir_delete(foopath)
  }
  fs::dir_create(where)
}
```

```{r create-package, eval = create, echo = debug, R.options = list(usethis.description = NULL)}
create_package(foopath, open = FALSE, rstudio = TRUE)
proj_set(foopath)
```

```{r set-proj-and-wd, include = debug, eval = create}
# being kind to the vignette developer
(owd <- getwd()) 
if (is.null(getOption("knitr.in.progress"))) {
  setwd(foopath)
  Sys.setenv(TESTTHAT = "true")
}
getwd()

## I normally am not this masochistic, but there is little choice
knitr::opts_knit$set(root.dir = foopath)
```


```{r sitrep, include = debug, eval = create}
## can't be in chunk above, because knitr
proj_sitrep()
```


If you use RStudio, navigate to this directory and double click on `foofactors.Rproj` to launch a new instance of RStudio in the project that is also your `foofactors` package. RStudio has special handling for packages and you should now see a Build tab in the same pane as Environment and History.

What files are in this new directory? Here's a listing using the [`fs` package][fs-web] (locally, you can consult your Files pane):

```{r init-show-files, echo = FALSE, eval = create}
dir_tree(path = ".", all = TRUE, glob = "TRUE", invert = TRUE, recurse = FALSE)
```

* `.Rbuildignore` lists files that we need to have around but that should not be included when building the R package from this source.
* `.gitignore` anticipates Git usage and ignores some standard, behind-the-scenes files created by R and RStudio. Even if you do not plan to use Git, this is harmless.
* `DESCRIPTION` provides [metadata about your package](https://r-pkgs.org/description.html). We will edit this shortly.
* [`NAMESPACE`](https://r-pkgs.org/namespace.html) declares the functions your package exports for external use and the external functions your package imports from other packages. At the moment, it holds temporary-yet-functional placeholder content.
* The `R/` directory is the ["business end" of your package](https://r-pkgs.org/r.html). It will soon contain `.R` files with function definitions.
* `foofactors.Rproj` is the file that makes this directory an RStudio project. Even if you don't use RStudio, this file is harmless. Or you can suppress its creation with `create(..., rstudio = FALSE)`.


## `use_git()` for version control

*This is optional, but a recommended practice in the long-term. We explain its importance in Chapter \@ref(version-control). If you don't use Git, simply ignore this and subsequent instructions related to version control.*

The `foofactors` directory is an R source package and an RStudio project. Now we make it a Git repository also, with `use_git()`.

```{r use-git, eval = create, chunk_envvar = c("TESTTHAT" = "true")}
use_git()  
```

<!--APH: added from Whole Game-->
In an interactive session, you will be asked if you want to commit some files here and you should probably accept the offer. Behind the scenes, we'll cause the same to happen for us.

```{r git2r-begin, echo = debug, eval = create}
suppressPackageStartupMessages(library(git2r))
repo <- repository(proj_get())
paths <- unlist(status(repo), use.names = FALSE)
add(repo, paths)
commit(repo, "Initial commit")
```


What's new? Only the creation of a `.git` directory, which is hidden in most contexts, including the RStudio file browser. Its existence is evidence that we have indeed initialized a Git repo here.

```{r post-git-file-list, echo = FALSE, eval = create}
dir_tree(path = ".", all = TRUE, glob = "TRUE", invert = TRUE, recurse = FALSE)
```


If you use RStudio, quit and then relaunch this project by double clicking on `foofactors.Rproj`. Now, in addition to package development support, you have access to a basic Git client in the Git tab of the Environment/History/Build pane. 

Click on History (the clock icon) and you should see the initial commit made by `use_git()`:


```{r inspect-first-commit, echo = FALSE, eval = create}
commits(repo)[[1]]
```


FYI: RStudio can initialize a Git repository, in any project, even if it's not an R package, as long as you've set up RStudio + Git integration. Do *Tools > Version Control > Project Setup...*. Then choose *Version control system: Git* and *initialize a new git repository for this project*.

## Write the first function

It is not too hard to find a puzzling operation involving factors. Let's see what happens when we catenate two factors.

```{r}
(a <- factor(c("character", "hits", "your", "eyeballs")))
(b <- factor(c("but", "integer", "where it", "counts")))
c(a, b)
```


Huh? Many people do not expect the result of combining two factors to be an integer vector consisting of the numbers 1, 2, 3, and 4. What if we coerce each factor to character, catenate, then re-convert to factor?

```{r}
factor(c(as.character(a), as.character(b)))
```

That seems to produce a result that makes more sense. Let’s drop that logic into the body of a function called `fbind()`:

```{r fbind-fodder, asis = TRUE, echo = FALSE, comment = NA}
fbind_fodder <- c(
  "fbind <- function(a, b) {",
  "  factor(c(as.character(a), as.character(b)))",
  "}"
)
cat(fbind_fodder, sep = "\n")
```

If you would like a review on writing functions in R, see Chapters \@ref(functions-part1), \@ref(functions-part2), \@ref(functions-part3), and \@ref(functions-practicum).


## `use_r()`

Where shall we define `fbind()`? Save it in a `.R` file, in the `R/` subdirectory of your package. A reasonable starting position is to make a new `.R` file for each function in your package and name the file after the function. As you add more functions, you’ll want to relax this and begin to group related functions together. We’ll save the definition of `fbind()` in the file `R/fbind.R`.

The helper `use_r()` creates and/or opens a script below `R/`. It really shines in a more mature package, when navigating between `.R` files and the associated tests.

```{r init-fbind, eval = create, chunk_envvar = c("TESTTHAT" = "true")}
use_r("fbind")
```

```{r write-fbind, include = FALSE, eval = create}
writeLines(fbind_fodder, path("R", "fbind.R"))
```

Put the definition of `fbind()` **and only the definition of `fbind()`** in `R/fbind.R` and save it. The file `R/fbind.R` should NOT contain any of the other top-level code we have recently executed, such as the definitions of factors `a` and `b`, `library(devtools)` or `use_git()`. This foreshadows an adjustment you’ll need to make as you transition from writing R scripts to R packages. Packages and scripts use different mechanisms to declare their dependency on other packages and to store example or test code. See the [R code][r-pkgs2-r-code] chapter of [R Packages][r-pkgs2] [@wickham-unpub] for more on this.

## `load_all()` to test drive

How do we test drive `fbind()`? If this were a regular R script, we might use RStudio to send the function definition to the R Console and define `fbind()` in the global workspace. Or maybe we’d call `source("R/fbind.R")`. For package development, however, `devtools` offers a more robust approach.

Call `load_all()` to make `fbind()` available for experimentation.

```{r load-all, eval = create}
load_all()
```

Now call `fbind(a, b)` to see how it works.

```{r, eval = create}
fbind(a, b)
```


Note that `load_all()` has made the `fbind()` function available, although it does not exist in the global workspace.

```{r, eval = create}
exists("fbind", where = ".GlobalEnv", inherits = FALSE)
```


`load_all()` simulates the process of building, installing, and loading the `foofactors` package. As your package accumulates more functions, some exported, some not, some of which call each other, some of which call functions from packages you depend on, `load_all()` gives you a much more accurate sense of how the package is developing than test driving functions defined in the global workspace. Also `load_all()` allows much faster iteration than actually building, installing, and loading the package.


__Review so far:__

* We wrote our first function, `fbind()`, to catenate two factors.
* We used `load_all()` to quickly make this function available for interactive use, as if we'd built and installed `foofactors` and loaded it via `library(foofactors)`.

You may want to learn the RStudio keyboard and menu shortcuts for `load_all()`:

* Windows & Linux: Ctrl+Shift+L
* macOS: Cmd+Shift+L
* In Environment/History/Build/Git pane:
  - *Build > More > Load All*
* From Build menu:
  - *Build > Load All*

## Commit `fbind()`

If you're using Git, use your preferred method to commit the new `R/fbind.R` file. We do so behind the scenes here. Here's the associated diff:

```{r fbind-commit, echo = debug, comment = NA, include = FALSE, eval = create}
add(repo, path = path("R", "fbind.R"))
commit(repo, message = "Add fbind()")
## tags might be useful for making stable links to the package at specific
## evolutionary stages
## possible convention: tag name = chunk label
#tag_name <- knitr::opts_current$get("label")
#tag(repo, tag_name, "initial creation of fbind()")
#tag(repo, "fbind-init", "initial creation of fbind()")
#sha <- (commits(repo)[[1]])@sha
```

```{r add-fbind-diff, echo = FALSE, eval = create, asis = TRUE}
commits(repo)[[1]]
tree_1 <- tree(commits(repo)[[2]])
tree_2 <- tree(commits(repo)[[1]])
cat(diff(tree_1, tree_2, as_char = TRUE))
```

From this point on, we commit after each step, each indicated by a brief message like that above. Remember [these commits](https://github.com/jennybc/foofactors/commits/master) are available in the public repository.

## `check()` and `install()`

We have empirical evidence that `fbind()` works, but how can we be sure that all the moving parts of the `foofactors` package still work? This may seem silly to check, after such a small addition, but it's good to establish the habit of checking this often.

How do we move our local source package through the necessary stages to get it properly installed?

```{r pkg-installation-diagram, echo = FALSE, out.width = "100%", fig.cap = "From [R Packages](https://r-pkgs.org/package-structure.html#package) [@wickham-unpub]"}
knitr::include_graphics("https://raw.githubusercontent.com/hadley/r-pkgs/master/diagrams/installation.png")
```

### Base utilities

`devtools` wraps the base utilities for package management, but in a way favorable for very quick iteration. Under the hood, here are the important commands (executed in the shell):

* [`R CMD build`](https://stat.ethz.ch/R-manual/R-patched/library/utils/html/PkgUtils.html) - converts a source package to a bundle or tarball.
* [`R CMD INSTALL`](https://stat.ethz.ch/R-manual/R-patched/library/utils/html/INSTALL.html) - installs a package bundle into a library.
* [`R CMD check`](https://stat.ethz.ch/R-manual/R-patched/library/utils/html/PkgUtils.html) - runs all sorts of checks. Even if you don't plan to submit your package to CRAN, it's a very good idea to make this part of your own quality standard.

In a shell, with working directory set to the parent of `foofactors`, here's what usage might look like:

``` shell
R CMD build foofactors
R CMD check foofactors_0.0.0.9000.tar.gz
R CMD INSTALL foofactors_0.0.0.9000.tar.gz
```

### `devtools` and RStudio

Luckily `devtools` and RStudio make these utilities very easy to access without going to the shell.

At intermediate milestones, you should check your package:

* In R Console
  - `devtools::check()`
* From RStudio
  - *Build > Check*

**Just this once, run `check()` with `document = FALSE`**, so we don't get ahead of ourselves. Specifically, I don't want to mess with our `NAMESPACE` file yet.

```{r first-check-fake, eval = FALSE}
check()
```

```{r first-check, eval = create, warning = TRUE, echo = FALSE}
shhh_check(error_on = "never")
```

**Read the output of the check!** Deal with problems early and often. It's just like incremental development of `.R` and `.Rmd`. The longer you go between full checks that everything works, the harder it becomes to pinpoint and solve your problems.

At this point, we expect 2 warnings (and 0 errors, 0 notes):

* `Non-standard license specification`
* `Undocumented code objects: 'fbind'`

We'll address both soon.

Since we've already made respectable interim progress, let's install the `foofactors` package into your library and load it via `devtools::install()`:

```{r first-install-fake, eval = FALSE}
install()
```

```{r first-install, eval = create, echo = FALSE, asis = TRUE, comment = NA}
cat(pretty_install(), sep = "\n")
```

Now we can load and use `foofactors` like any other package.

A shortcut for "build, install, and reload" is offered in the RStudio Build pane:

* *Build > Build & Reload*

## Installation test

Now that we've installed `foofactors` properly, let's revisit our small example from the top. This is a good time to restart your R session and ensure you have a clean workspace.

Is `foofactors` indeed available for loading?

```{r}
installed.packages() %>% 
  as_tibble() %>% 
  select(Package) %>% 
  filter(Package == "foofactors")
```

Yes! Load and use it.

```{r}
library(foofactors)
a <- factor(c("character", "hits", "your", "eyeballs"))
b <- factor(c("but", "integer", "where it", "counts"))
fbind(a, b)
```

Success!

## Edit `DESCRIPTION`

Before we tackle the warnings about the license and documentation, let’s work on the boilerplate content in `DESCRIPTION.` The `DESCRIPTION` file provides metadata about your package:

* Read more in [R Packages][r-pkgs2-description] [@wickham-unpub]
* Read more in [Writing R Extensions](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#The-DESCRIPTION-file)

Make these edits:

* Make yourself the author.
* Write some descriptive text in the `Title` and `Description` fields. Note that CRAN is very particular about these fields, so if you want to keep passing `check()`, read [this section](https://r-pkgs.org/description.html#pkg-description) of R Packages [@wickham-unpub].

When you're done, `DESCRIPTION` should look similar to this:

```{r description-fodder, asis = TRUE, echo = FALSE, comment = NA, eval = create}
DESCRIPTION_fodder <- c(
  'Package: foofactors',
  'Title: Make Factors Less Aggravating',
  'Version: 0.0.0.9000',
  'Authors@R:',
  '    person("Jane", "Doe", email = "jane@example.com", role = c("aut", "cre"))',
  'Description: Factors have driven people to extreme measures, like ordering',
  '    custom conference ribbons and laptop stickers to express how HELLNO we',
  '    feel about stringsAsFactors. And yet, sometimes you need them. Can they',
  '    be made less maddening? Let\'s find out.',
  'License: What license it uses',
  'Encoding: UTF-8',
  'LazyData: true'
)
writeLines(DESCRIPTION_fodder, "DESCRIPTION")
cat(DESCRIPTION_fodder, sep = "\n")
```


```{r commit-description, echo = debug, comment = NA, eval = create}
add(repo, path = "DESCRIPTION")
commit(repo, message = "Edit DESCRIPTION")
```

## `use_mit_license()`

> [Pick a License, Any License. -- Jeff Atwood](http://blog.codinghorror.com/pick-a-license-any-license/)

For `foofactors`, we use the MIT license. This requires specification in `DESCRIPTION` and an additional file called `LICENSE`, naming the copyright holder and year. We create that now via the helper function `use_mit_license()`. Substitute your name here.

```{r use-mit-license, eval = create}
use_mit_license("Jane Doe")
```

Open the newly created `LICENSE` file and confirm it has the current year and your name.

```{r license-fodder, asis = TRUE, echo = FALSE, comment = NA, eval = create}
cat(readLines("LICENSE"), sep = "\n")
```

Like other license helpers, `use_mit_license()` also puts a copy of the full license in `LICENSE.md` and adds this file to `.Rbuildignore`. It’s considered a best practice to include a full license in your package’s source, such as on GitHub, but CRAN disallows the inclusion of this file in a package tarball.

```{r commit-license, echo = debug, comment = NA, eval = create}
add(repo, path = "LICENSE")
commit(repo, message = "Add LICENSE")
```

For future projects, there is more guidance on licenses in these sources:

* [R Packages](https://r-pkgs.org/description.html#license) [@wickham-unpub]
* [Writing R Extensions](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Licensing)
* GitHub's guide at <http://choosealicense.com>

## `document()`

Wouldn't it be nice to get help on `fbind()`, just like we do with other R functions? This requires that your package have a special R documentation file, `man/fbind.Rd`, written in an R-specific markup language that is sort of like LaTeX. Luckily, we don't necessarily have to author that directly.

We write a specially formatted comment right above `fbind()`, in its source file, and then let a package called [`roxygen2`][roxygen2-cran] handle the creation of `man/fbind.Rd`.  To read more about the motivation and mechanics of `roxygen2`, read the [Object documentation](https://r-pkgs.org/man.html) chapter of R Packages [@wickham-unpub].

If you use RStudio, open `R/fbind.R` in the source editor and put the cursor somewhere in the `fbind()` function definition. Now do *Code > Insert Roxygen Skeleton*. A very special comment should appear above your function, in which each line begins with `#'`. RStudio only inserts a barebones template, so you will need to edit it to look something like that below.

If you don’t use RStudio, create the comment yourself. Regardless, you should modify it to look something like this:

```{r fbind-roxygen-header, asis = TRUE, echo = FALSE, comment = NA, eval = create}
fbind_roxygen_header <- c(
  "#' Bind two factors",
  "#'",
  "#' Create a new factor from two existing factors, where the new factor's levels",
  "#' are the union of the levels of the input factors.",
  "#'",
  "#' @param a factor",
  "#' @param b factor",
  "#'",
  "#' @return factor",
  "#' @export",
  "#' @examples",
  "#' fbind(iris$Species[c(1, 51, 101)], PlantGrowth$group[c(1, 11, 21)])"
)
fbind_safe <- readLines(path("R", "fbind.R"))
writeLines(
  c(fbind_roxygen_header, paste(fbind_safe, collapse = "\n")),
  path("R", "fbind.R")
)
cat(fbind_roxygen_header, sep = "\n")
```

```{r commit-fbind-roxygen-header, echo = debug, comment = NA, eval = create}
add(repo, path = file.path("R", "fbind.R"))
commit(repo, message = "Add roxygen header to document fbind()")
```

But we're not done yet! We still need to trigger the conversion of the roxygen comment into `man/fbind.Rd`. You can do this from the RStudio IDE or from R:

* From RStudio:
  - *Build > More > Document*
* From R:
  - `document()`, which is a wrapper function provided by `devtools.`
  Under the hood, it's calling the `roxygen2` package.


```{r document-fbind, eval = create}
document()
```

You should now be able to preview your help file like so:

```{r eval = FALSE}
?fbind
```

Does it show up in the usual help pane? Looking like real documentation? Isn't that exciting?

Your package's documentation won't be properly wired up until you do a full "Build & Reload". I'm referring to the links between help files, the link to the package index, etc.

The RStudio [Package Development with `devtools` Cheat Sheet][devtools-cheatsheet] has really nice coverage of roxygen comment syntax. You can also get information from *Help > Roxygen Quick Reference*.

### `NAMESPACE` changes

In addition to converting `fbind()`'s special comment into `man/fbind.Rd`, the call to `devtools::document()` updates the `NAMESPACE` file, based on `@export` directives found in roxygen comments. Open `NAMESPACE` for inspection. The contents should be:

```{r asis = TRUE, echo = FALSE, comment = NA, eval = create}
cat(readLines("NAMESPACE"), sep = "\n")
```

It no longer has the placeholder content saying "export everything". Instead, there is now an explicit directive to export the `fbind()` function.

The export directive in `NAMESPACE` is what's required to "export a function" and it's what makes `fbind()` available to a user after loading `foofactors` via `library(foofactors)`. Just as it is entirely possible to author `.Rd` files "by hand", you can manage `NAMESPACE` explicitly yourself. But we are opting to delegate this to `devtools` (and `roxygen2`).

```{r commit-namespace, echo = debug, comment = NA, eval = create}
add(repo, path = c("DESCRIPTION", "NAMESPACE", path("man", "fbind.Rd")))
commit(repo, message = "Run document()")
```

## `check()` and `install()` again

`foofactors` should pass `R CMD check` cleanly now and forever more: 0 errors, 0 warnings, 0 notes.

```{r first-clean-check-fake, eval = FALSE}
check()
```

```{r first-clean-check, eval = create, warning = TRUE, echo = FALSE}
shhh_check(error_on = "never")
```

Since we have a minimum viable product now, let's install the `foofactors` package into your library via `devtools::install()`:

```{r second-install-fake, eval = FALSE}
install()
```

```{r second-install, eval = create, echo = FALSE, asis = TRUE, comment = NA}
cat(pretty_install(), sep = "\n")
```

RStudio exposes similar functionality in the *Build* menu and in the Build pane via "Install and Restart".

Now we can load and use `foofactors` like any other package. Let's revisit our small example from the top. This is a good time to restart your R session and ensure you have a clean workspace.

```{r, eval = create}
library(foofactors)

a <- factor(c("character", "hits", "your", "eyeballs"))
b <- factor(c("but", "integer", "where it", "counts"))

fbind(a, b)
```

Success!

## `use_testthat()`

We've tested `fbind()` informally, in a single example. We can formalize and expand this with some unit tests. This means we express a few concrete expectations about the correct `fbind()` result for various inputs.

First, we declare our intent to write unit tests and to use the `testthat` package for this, via `use_testthat()`:

```{r use-testthat, eval = create}
use_testthat()
```

This initializes the unit testing machinery for your package. It adds `Suggests: testthat` to `DESCRIPTION`, creates the directory `tests/testthat`, and adds the script `test/testthat.R`.

```{r commit-testthat-init, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Add testing infrastructure")
```

However, it's still up to YOU to write the actual tests!

The helper `use_test()` opens and/or creates a test file. You can provide the file's basename or, if you are editing the relevant source file in RStudio, it will be automatically generated. Since this book is built non-interactively, we must provide the basename explicitly:

```{r test-fbind, eval = create}
use_test("fbind")
```

This creates the file `tests/testthat/test-fbind.R`. Put this content in it:

```{r test-fodder, asis = TRUE, echo = FALSE, comment = NA, eval = create}
test_fodder <- c(
  "context(\"Binding factors\")",
  "",
  "test_that(\"fbind binds factor (or character)\", {",
  "  x <- c('a', 'b')",
  "  x_fact <- factor(x)",
  "  y <- c('c', 'd')",
  "  z <- factor(c('a', 'b', 'c', 'd'))",
  "",
  "  expect_identical(fbind(x, y), z)",
  "  expect_identical(fbind(x_fact, y), z)",
  "})"
)
test_path <- file.path("tests", "testthat", "test-fbind.R")
writeLines(test_fodder, test_path)
cat(test_fodder, sep = "\n")
```

This tests that `fbind()` gives an expected result when combining two factors and a character vector and a factor.

```{r commit-fbind-test, echo = debug, comment = NA, eval = FALSE}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Test fbind()")
```

Run this test interactively, as you will when you write your own. Note you'll have to load `testthat` via `library(testthat)` in your R session first and you'll probably want to `load_all()`.

Going forward, your tests will mostly run *en masse* and at arm's length:

* In RStudio:
  - *Build > Test package*
* In R:
  - `test()`, which is a convenience wrapper in `devtools` that calls the `testthat` package.

```{r test, eval = create, message = FALSE}
test()
```

Your tests are also run whenever you `check()` the package. In this way, you basically augment the standard checks with some of your own, that are specific to your package.

For much more guidance, read the [Testing][r-pkgs2-tests] chapter in R Packages [@wickham-unpub].

## `use_package()`

You will inevitably want to use a function from another package in your own package. Just as we needed to **export** `fbind()`, we need to **import** functions from the namespace of other packages. If you plan to submit a package to CRAN, note that this even applies to functions in packages that you think of as "always available", such as `stats::median()` or `utils::head()`.

There is more than one way to go about this. We use the approach recommended in the [Namespace][r-pkgs2-namespace] chapter of R Packages [@wickham-unpub] and in the [rOpenSci Packaging Guide](https://ropensci.github.io/dev_guide/building.html#package-dependencies).  The general usage pattern is this: give the name of the external package, then two colons, then the function to call.

First, declare your general intent to use some functions from the `forcats` namespace with `usethis::use_package()`:

```{r use-forcats, eval = create}
use_package("forcats")
```

This adds the `forcats` package to the "Imports" section of `DESCRIPTION`. And that is all.

```{r commit-forcats-imports, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Import forcats")
```


Now we add a new function to `foofactors` that does, indeed, use a function from `forcats.` Imagine we want a frequency table for a factor, as a regular data frame with nice variable names, versus as an object of class `table` or something with odd names. Let's also sort the rows so that the most prevalent level is at the top. 

Initiate a new `.R` file below `R/` with `use_r()`:

```{r init-fcount, eval = create, chunk_envvar = c("TESTTHAT" = "true")}
use_r("fcount")
```

Put this content in the file `R/fcount.R`:

```{r fcount-fodder, asis = TRUE, echo = FALSE, comment = NA}
fcount_fodder <- c(
  "#' Make a sorted frequency table for a factor",
  "#'",
  "#' @param x factor",
  "#'",
  "#' @return A tibble",
  "#' @export",
  "#' @examples",
  "#' fcount(iris$Species)",
  "fcount <- function(x) {",
  "  forcats::fct_count(x, sort = TRUE)",
  "}"
)
cat(fcount_fodder, sep = "\n")
```

```{r write-fcount, include = FALSE, eval = create}
writeLines(fcount_fodder, path("R", "fcount.R"))
```

Notice how we preface the call to a `forcats` functions with `forcats::`. This specifies that we want to call the `fct_count()` function from the `forcats` namespace. There is more than one way to call functions in other packages and the one we espouse here is explained fully in the [Namespace][r-pkgs2-namespace] chapter of R Packages [@wickham-unpub].

```{r commit-fcount, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Add fcount()")
```

Try out the new `fcount()` function by simulating package installation via `load_all()`:

```{r fcount-test-drive, eval = create}
load_all()
fcount(iris$Species)
```

Generate the associated help file via `document()` or *Build > Document*.

```{r document-fcount, eval = create}
document()
```

```{r commit-fcount-rd, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Document fcount()")
```

## `use_package_doc()`

<!--APH: Update to use the new sentinel and describe it accurately? Maybe devtools should be updated to do that too?-->

Let's start adding package-level documentation. Your package as a whole can have its own `.Rd` file. You can see an example by entering `package?dplyr` in R Console. Read more about the uses of package-level documentation in [R Packages](https://r-pkgs.org/man.html#man-packages) [@wickham-unpub].

Set this up with `usethis::use_package_doc()`:

```{r use-package-doc, eval = create}
use_package_doc()
```

This creates a peculiar dummy file `R/foofactors-package.R` with a roxygen header, that is documenting just ... `NULL`. The purpose of this is simply to trigger the generation of a package-level `.Rd` file.

Edit `R/foofactors-package.R` to look something like this. I just copied info from `DESCRIPTION` but you can add more info here and possibly should in real life. This file isn't subject to the same CRAN checks as `DESCRIPTION`, so you have much more freedom.


```{r pkg-doc-fodder, asis = TRUE, echo = FALSE, comment = NA}
pkg_doc_fodder <- trimws("
#' foofactors: Make Factors Less Aggravating
#'
#' Factors have driven people to extreme measures, like ordering custom
#' conference ribbons and laptop stickers to express how HELLNO we feel about
#' stringsAsFactors. And yet, sometimes you need them. Can they be made less
#' maddening? Let's find out.
#'
#' @name foofactors
#' @docType package
NULL
")
writeLines(pkg_doc_fodder, file.path("R", "foofactors-package.R"))
cat(pkg_doc_fodder, sep = "\n")
```

```{r commit-package-doc, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Add package-level doc")
```

Don't forget to run `document()`!

```{r document-package, eval = create}
document()
```

```{r commit-package-Rd, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Run document()")
```

Have a look at your new package-level docs:

```{r eval = FALSE}
?foofactors
```


## `use_vignette()`

A piece of package-level documentation that's probably familiar to you is the vignette. This is a great place to put a fully developed example that calls multiple functions from your package to do something useful and realistic. See the [Vignettes][r-pkgs2-vignettes] chapter of R Packages [@wickham-unpub] for more.

Use `usethis::use_vignette()` to initialize a new vignette:

```{r use-vignette, eval = create}
use_vignette("foofactors-vignette")
```

Here's what happens:

* Adds `knitr` and `rmarkdown` to `Suggests` in `DESCRIPTION`.
* Creates a new file with boilerplate vignette content, `vignettes/foofactors-vignette.Rmd`.
* Adds `inst/doc` to `.gitignore`.
* If using RStudio, opens `vignettes/foofactors-vignette.Rmd` for editing.

```{r commit-boilerplate-vignette, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Init vignette")
```

Now you need to edit `vignettes/foofactors-vignette.Rmd`. At the very least, do this:

* Replace **both instances** of "Vignette Title" in the YAML with an actual title and with the same title.
* List yourself as author or remove that line.
* Remove the boilerplate content and throw in some usage. Even early on, just mine your examples or tests for something to throw in here. It is better than nothing.

The vignette source can be seen here: [foofactors-vignette.Rmd](https://raw.githubusercontent.com/rstudio-education/stat545-reboot/master/supporting-docs/foofactors-vignette.Rmd)

```{r copy-vignette, asis = TRUE, echo = FALSE, comment = NA, include = debug}
vignette_path <- path("vignettes", "foofactors-vignette.Rmd")
file_copy(path(owd, "supporting-docs", "foofactors-vignette.Rmd"),
          new_path = vignette_path, overwrite = TRUE)
#cat(readLines(vignette_path), sep = "\n")
```

```{r commit-vignette, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Write vignette")
```

How to see your compiled vignette? For a quick preview, just use RStudio's "Knit HTML" button. Problem is, the downstream products aren't saved anywhere in your package, so you'll need to redo this every time you want to look at the vignette.

If you want to hold on to a compiled vignette, for your own sake or to push to GitHub, it's a little fiddly. I'm not executing any of these for real, so don't expect to see the result in the `foofactors` repo on GitHub.

__Option 1:__

```{r eval = FALSE}
build_vignettes()
## Build and reload !!!
browseVignettes("foofactors")
## look at your vignette
```

This puts your vignette (`.Rmd` and any downstream products, such as `.html`) in `inst/doc` but because we are git-ignoring `inst/doc` this won't make a rendered vignette available on GitHub. You can however view it locally.

__Option 2:__

In RStudio, do *Tools > Project Options > Build Tools > Generate documentation with Roxygen > Configure > Use roxygen to generate vignettes*. Then when you `document()`, downstream products, such as vignette `.html` will be left behind in `vignettes/`. There is nothing stopping you from including something like this in vignette YAML:

``` yaml
output:
  rmarkdown::html_vignette:
    toc: true
    keep_md: true
```

Which means vignette `.md` would be left behind in `vignettes/` and therefore potentially available on GitHub.

<!--APH: I'm really not sure what to advise here?-->

## `use_github()`

This creates a remote companion repository on GitHub, sets an upstream tracking branch for `master`, and makes an initial push. If you use RStudio, this means your Push and Pull buttons will work. If you prefer, you can always create the GitHub repo in the browser and use command line Git to add the GitHub remote and set an upstream tracking branch for `master`.

To connect to GitHub, under the hood `devtools` calls the GitHub API. This means you'll need to use your GitHub account to get a personal access token (PAT).

*See the [Cache credentials for HTTPS](https://happygitwithr.com/credential-caching.html) chapter of [Happy Git and GitHub for the useR](https://happygitwithr.com).*

Get a PAT here <https://github.com/settings/tokens>. Make sure the "repo" scope is included.

Store your PAT as an environment variable named `GITHUB_PAT` in `~/.Renviron`, which holds environment variables that should be available to all R processes. `devtools` will look here for it, by default. Here "~/" means your home directory. If you're not sure where that is, execute `normalizePath("~/")` in R console. **This file should be named `.Renviron`, not `.Renviron.R`, look like this, and end in a newline:**

``` sh
GITHUB_PAT=??40-RANDOM-LETTERS-AND-DIGITS-GO-HERE??
```

Restart R and check that the PAT is now available:

```{r eval = FALSE}
Sys.getenv("GITHUB_PAT")
```

You should see your PAT print to screen.

Submit the appropriate line below to use `usethis::use_github()` to connect the local `foofactors` Git repo to a new GitHub repo:

```{r eval = FALSE}
## public repo using https
use_github(protocol = "https")

## private repo using https
use_github(protocol = "https", private = TRUE)

## public repo using ssh
use_github()

## private repo using ssh
use_github(private = TRUE)

```

```{r use-github, echo = FALSE, eval = github}
#use_github(protocol = "https")
use_github(protocol = "https", private = TRUE)
```

```{r}
#> Using GitHub PAT from envvar GITHUB_PAT
#> * Git is already initialized
#> * Checking title and description
#>   Title: Make Factors Less Annoying
#>   Description: Factors have driven people to extreme measures, like ordering
#> custom conference ribbons and laptop stickers to express how HELLNO we
#> feel about stringsAsFactors. And yet, sometimes you need them. Can they
#> be made less maddening? Let's find out.
#> * Creating GitHub repository
#> * Adding GitHub remote
#> * Adding GitHub links to DESCRIPTION
#> * Pushing to GitHub and setting remote tracking branch
#> * View repo at https://github.com/jennybc/foofactors
```


Go look at your package's repo on GitHub! It should look very similar to the package created by this vignette: <https://github.com/jennybc/foofactors>. If you use RStudio, your Pull and Push buttons should now work.

## `use_readme_rmd()`

Now that your package is on GitHub, the `README.md` file matters. It is the package's home page and welcome mat, at least until you decide to give it a website (see [`pkgdown`][pkgdown-web]) or submit it to CRAN (see the [Releasing a package][r-pkgs2-release] chapter in the R Packages book [@wickham-unpub]).


The `use_readme_rmd()` function initializes a basic, executable `README.Rmd` ready for you to edit:

```{r use-readme-rmd, eval = create, chunk_envvar = c("TESTTHAT" = "true")}
use_readme_rmd()
```

In addition to creating `README.Rmd`, this adds some lines to `.Rbuildignore`, and creates a Git pre-commit hook to help you keep `README.Rmd` and `README.md` in sync.

`README.Rmd` already has sections that:

* Prompt you to describe the purpose of the package.
* Provide code to install your package.
* Prompt you to show a bit of usage.

How to populate this skeleton? Copy stuff liberally from `DESCRIPTION`, `R/foofactors-package.R`, examples, and the vignette. Anything is better than nothing. Otherwise ... do you expect people to install your package and comb through individual help files to figure out how to use it?

We write the `README` in R Markdown, so it can feature actual usage. It will load the currently installed version of your package, so this is a good time to do "Build & Reload" in RStudio. Or do this in R Console:

```{r pre-readme-install-fake, eval = FALSE}
install()
```

```{r pre-readme-install, eval = create, echo = FALSE, asis = TRUE, comment = NA}
cat(pretty_install(), sep = "\n")
```

If RStudio has not already done so, open `README.Rmd` for editing. Make sure it shows some usage of `fbind()` and/or `fcount()`, for example.

```{r commit-readme-rmd, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Set up README.Rmd")
```

The `README.Rmd` we use can be seen here: [README.Rmd](https://raw.githubusercontent.com/jennybc/foofactors/master/README.Rmd). These are the contents:

```{r copy-readme-rmd, include = debug, eval = create}
file_copy(path(owd, "supporting-docs", "foofactors-README.Rmd"),
          new_path = "README.Rmd", overwrite = TRUE)
```

```{r cat-readme-rmd, asis = TRUE, echo = FALSE, comment = NA, eval = create}
cat(readLines("README.Rmd"), sep = "\n")
```

Don't forget to render it to make `README.md`! The pre-commit hook should remind you if you try to commit `README.Rmd` but not `README.md` and also when `README.md` appears to be out-of-date.

```{r eval = FALSE}
rmarkdown::render("README.Rmd") ## or use "Knit HTML" in RStudio
```

```{r render-readme-rmd, include = debug, eval = create}
callr::r(
  function(.input) rmarkdown::render(input = .input, quiet = TRUE),
  args = list(.input = "README.Rmd")
)
```

You can see the rendered `README.md` simply by [visiting `foofactors` on GitHub](https://github.com/jennybc/foofactors#readme).

Finally, don't forget to do one last commit. And push, if you're using GitHub.

```{r commit-rendered-readme, echo = debug, comment = NA, eval = create}
paths <- unlist(status(repo))
add(repo, path = paths)
commit(repo, message = "Write README.Rmd and render")
```

```{r final-push, include = debug, eval = FALSE}
push(repo, credentials = cred_user_pass("EMAIL",
                                        Sys.getenv("GITHUB_PAT")))
## if tags become useful, here's how to push one
## push(repo, "origin", "refs/tags/fbind-init",
##      credentials = cred_user_pass("EMAIL", Sys.getenv("GITHUB_PAT")))
## not clear if git2r has easy way to push all tags
## https://github.com/ropensci/git2r/issues/265
```

## The End

Let's run `check()` again to make sure all is still well.

```{r final-check-fake, eval = FALSE}
check()
```

```{r final-check, eval = create, warning = TRUE, echo = FALSE}
shhh_check(error_on = "never")
```

`foofactors` should have no errors, warnings or notes. This would be a good time to do "Build and reload" to celebrate.

```{r final-install-fake, eval = FALSE}
install()
```

```{r final-install, eval = create, echo = FALSE, asis = TRUE, comment = NA}
cat(pretty_install(), sep = "\n")
```

As a review, let's take a final look at our project structure:

```{r final-file-list, echo = FALSE, eval = create}
dir_tree(path = ".", all = TRUE, glob = "TRUE", invert = TRUE, recurse = FALSE)
```

Feel free to visit the [`foofactors` package](https://github.com/jennybc/foofactors) on GitHub, which is exactly as developed in this chapter. The commit history reflects each individual step, so use the diffs to see the addition and modification of files, as the package evolved.


```{r teardown, include = debug, eval = create}
remove.packages("foofactors")
## interactive dev
setwd(owd)
knitr::opts_knit$set(root.dir = owd)
knitr::opts_knit$get("root.dir")
```

```{r include = debug}
## FUTURE JENNY! don't move this into the previous chunk!
## you can't remove current working directory and the root.dir change
## doesn't take effect until you enter the next chunk
getwd()

## for now, I like leaving this for inspection
#unlink(ff_path, recursive = TRUE)
```

```{r links, child="links.md"}
```